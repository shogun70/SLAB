<?xml version="1.0"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<script type="text/html" src="../ECMAScript5.xhtml"></script>
<script type="text/javascript">
<![CDATA[

(function() { // A few cross-browser fixes

if (!document.parentWindow) document.parentWindow = window;

//	document.documentURI for a range of browsers
var _documentURI = document.documentURI || document.baseURI || document.URL || document.url || document.location;
if (!document.documentURI) document.documentURI = _documentURI;

// make visible window["[[DOMDocument]]"], etc in Safari-2
document.createElement("select").options;
document.createTextNode("text");
document.createAttribute("attribute");

var safari2Prototypes = {
	Node: "[[DOMNode.prototype]]",
	Text: "[[DOMText.prototype]]",
	Document: "[[DOMDocument.prototype]]",
	Element: "[[DOMElement.prototype]]",
	Event: "[[DOMEvent.prototype]]"
}

for (var name in safari2Prototypes) {
	var proto = safari2Prototypes[name];
	if (!window[proto]) continue;
	if (!window[name]) window[name] = function() {};
	window[name].prototype = window[proto];
}

// IE8
if (!window.HTMLElement && window.Element) window.HTMLElement = window.Element;
if (!window.HTMLOptionsCollection && window.HTMLCollection) window.HTMLOptionsCollection = window.HTMLCollection;
if (!window.Document && window.HTMLDocument) window.Document = window.HTMLDocument;

// Special rules for Window since there is only one instance
if (!window.Window) {
	window.Window = function() {};
	window.Window.prototype = window;
}

// And for Document since there is only one instance. FIXME not strictly true
if (!window.Document) {
	window.Document = function() {};
	window.Document.prototype = document;
}


})();

Meeko.stuff.domSystem = (function() {

var domSystem = {};

var interfaceTable = [
//	{ name: "Node" },
	{ name: "Window", nodeType: 0 }, // NOTE treated as a node for internal purposes
	{ name: "Text", base: "Node", nodeType: 3 }, // Node.TEXT_NODE },
	{ name: "Document", base: "Node", nodeType: 9 }, // Node.DOCUMENT_NODE },
	{ name: "HTMLDocument", base: "Document", nodeType: 9 }, // Node.DOCUMENT_NODE },
	{ name: "Element", base: "Node", nodeType: 1 }, // Node.ELEMENT_NODE },
	{ name: "HTMLElement", base: "Element", nodeType: 1 }, // Node.ELEMENT_NODE },
	{ name: "HTMLLinkElement", element: "link", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE },
	{ name: "HTMLStyleElement", element: "style", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE },
	{ name: "HTMLFormElement", element: "form", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLSelectElement", element: "select", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLInputElement", element: "input", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLTableElement", element: "table", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLTableSectionElement", element: "thead, tfoot, tbody", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLTableRowElement", element: "tr", base: "HTMLElement", nodeType: 1 } // Node.ELEMENT_NODE }
];

var interfacesByName = {};
Object.forEach (interfaceTable, function(row) {
	interfacesByName[row.name] = row;
})

var interfaceInheritanceChains = {};
for (var name in interfacesByName) {
	interfaceInheritanceChains[name] = [];
	var chain = interfaceInheritanceChains[name];
	do {
		chain.unshift(name);
		var ifSpec = interfacesByName[name];
		name = (ifSpec) ? ifSpec.base : null;
	} while (name);
}

function getLocalName(element) {
	return (element.localName) ? element.localName : element.tagName.replace(element.prefix+":", "");	
}
var htmlElementRulesTree = { // TODO this tree should be generated from interfaceTable[]
	_test: function(node) { return getLocalName(node).toLowerCase(); }, // FIXME toLowerCase() should only apply to HTML elts
	"link": "HTMLLinkElement",
	"style": "HTMLStyleElement",
	"form": "HTMLFormElement",
	"select": "HTMLSelectElement",
	"input": "HTMLInputElement",
	"table": "HTMLTableElement",
	"thead": "HTMLTableSectionElement",
	"tfoot": "HTMLTableSectionElement",
	"tbody": "HTMLTableSectionElement",
	"tr": "HTMLTableRowElement",
	_default: "HTMLElement"
}

var interfaceRulesTree = {
	_test: function(node) { return (node != window) ? node.nodeType : 0; },
	0: "Window",
	1: { // Node.ELEMENT_NODE
		_test: function(node) { return node.namespaceURI },
		"http://www.w3.org/1999/xhtml" : htmlElementRulesTree,
		_null: htmlElementRulesTree,
		_default: "Element"
	},
	9: { // Node.DOCUMENT_NODE
		_test: function(node) { return node.namespaceURI },
		"http://www.w3.org/1999/xhtml" : "HTMLDocument",
		_null: "HTMLDocument",
		_default: "Document"
	}
}

// TODO all this node manager stuff assumes that nodes are only released on unload
// This might need revising
var nodeTable = new Array(13);
for (var i=0; i<13; i++) {
	nodeTable[i] = [];
}
var nodeStorage = {};

var nodeManager = {};
nodeManager.getStorage = function(node) {
	if (node.slabID) return nodeStorage[node.slabID];
	var nodeType = (node != window) ? node.nodeType : 0;
	var nodeList = nodeTable[nodeType];
	var index = nodeList.length;
	nodeList.push(node);
	var slabID = "slab_" + nodeType + "_" + index;
	node.slabID = new String(slabID); // NOTE so that node cloning doesn't copy slabID
	return nodeStorage[slabID] = {};
}
nodeManager.releaseNodesByType = function(type, callback, context) {
	var nodeList = nodeTable[type];
	for (var i=nodeList.length-1; i>=0; i--) {
		var node = nodeList[i];
		delete nodeList[i];
		if (callback) callback.call(context, node);
		delete nodeStorage[node.slabID];
		node.slabID = null; // NOTE can't delete node properties in IE
	}
	nodeTable[type] = [];
}

var privateKey = Math.random();

function _bind(dst, src, name, over) {
	if (src[name] == null) return;
	if (!over && (dst.hasOwnProperty && dst.hasOwnProperty(name) || dst[name] != null)) return;
	if ("function" == typeof src[name]) return dst[name] = function() { return src[name].apply(src, arguments); };
	if (dst.__defineGetter__) return dst.__defineGetter__(name, function() { return src[name]; });
	return dst[name] = src[name];
}
function bind(dest, source, fields, override) {
	if (fields && fields.length != null) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_bind(dest, source, name, override);
		}
	}
	else {
		for (var name in source) _bind(dest, source, name, override);
	}
	return dest;
}

function _release(dst, src, name) {
	if (dst[name] == null) return;
	dst[name] = null;
}
function release(dest, source, fields) {
	if (fields && fields.length) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_release(dest, source, name);
		}
	}
	else {
		for (var name in source) _release(dest, source, name);
	}
	return dest;
}

function _hide(node, name) {
	if (!node[name]) return;
	var _name = "_" + name;
	var __name = "__" + name;
	if (typeof node[name] === "function" || node.nodeType) node[_name] = node[name];
	else {
		node[__name] = node[name];
		node[_name] = function() { return this[__name].apply(this, arguments); }
	}
	// delete node[name];
	node[name] = null;
}
function hide(node, fields) {
	for (var n=fields.length, i=0; i<n; i++) _hide(node, fields[i]);
}

function _restore(node, name) {
	var _name = "_" + name;
	var __name = "__" + name;
	if (node[_name]) {
		node[name] = node[_name];
		// delete node[_name];
		node[_name] = null;
	}
	if (node[__name]) {
		node[name] = node[__name];
		// delete node[__name];
		node[__name] = null;
	}
}
function restore(node, fields) {
	for (var n=fields.length, i=0; i<n; i++) {
		var name = fields[i];
	}
}

/*
 DOMInterface is a ClassFactory for dom-binding classes. Usage:
   var HTMLElement = new DOMInterface("HTMLElement");
 The DOMInterface class is then attached to a node with:
   HTMLElement.attach(node);
*/
function copyPrototype(node, prototype) { // FIXME orthogonality
	function _copy(node, prototype, field) {
		var _field = "_" + field;
		if (node[field]) node[_field] = node[field];
		var slot = prototype[field];
		if (typeof slot === "function") node[field] = slot;
		else {
			slot = Object.getOwnPropertyDescriptor(prototype, field);
			node[field] = slot.get.call(node);
		}
	}
	for (var field in prototype) _copy(node, prototype, field);
}

function createBindingInstance(node, spec) {
	var binding = new spec;
	binding.domNode = node;
	if (node.nodeType === 1) binding.boundElement = node;
	if (binding.domAttach) binding.domAttach();
	return binding;
}

var DOMInterface = function(name) {
	this.name = name;
	this.prototype = {};
	this.bindings = [];
}
DOMInterface.prototype.getStorage = function(node) {
	var ifName = "_" + this.name;
	var store = nodeManager.getStorage(node);
	var domStore = store[ifName];
	// TODO should check if the iface is valid for node.
	if (!domStore) domStore = store[ifName] = {};
	return domStore;
}
DOMInterface.prototype.removeStorage = function(node) {
	var ifName = "_" + this.name;
	var store = nodeManager.getStorage(node);
	var domStore = store[ifName];
	if (!domStore) throw "Failure removing non-existant "+this.name+" interface from "+node.tagName;
	store[ifName] = null;
	return domStore;
}

DOMInterface.prototype.attach = function(node) {
	if (this.baseInterface) this.baseInterface.attach(node);
	var domStore = this.getStorage(node);
	for (var n=this.bindings.length, i=0; i<n; i++) {
		if (domStore[i]) continue;
		var bindingSpec = this.bindings[i];
		if (!bindingSpec.prototype.domAttach) continue;
		var binding = createBindingInstance(node, bindingSpec);
		domStore[i] = binding;
	}
	var domPublic = Object.keys(this.prototype);
	hide(node, domPublic);
	copyPrototype(node, this.prototype);
}
DOMInterface.prototype.detach = function(node) { // FIXME
	var ifName = "_" + this.name;
	this.removeStorage(node);
	if (this === window[this.name]) {
		var domPublic = Object.keys(this.prototype);
		restore(node, domPublic);
	}
	if (this.baseInterface) this.baseInterface.detach(node);
}

function bindProperty(node, implementation, field) {
	if (typeof implementation.prototype[field] === "function") node[field] = function() {
		var binding = implementation.getStorage(this);
		return binding[field].apply(binding, arguments);
	}
	else Object.defineProperty(node, field, {
		get: function() {
			var binding = implementation.getStorage(this);
			return binding[field];
		}
	});
}
DOMInterface.prototype.addBinding = function(spec) {
	var ifName = "_" + this.name;
	var implementation = function() {};
	implementation.prototype = spec.prototype;

	implementation.domInterface = this;
	this.bindings.push(implementation);
	var index = this.bindings.length - 1;
	var domInterface = this;
	implementation.getStorage = function(node) {
		var domStore = domInterface.getStorage(node);
		if (!domStore) throw "Binding not valid for that node.";
		var binding = domStore[index];
		if (!binding) {
			binding = createBindingInstance(node, implementation);
			domStore[index] = binding;
		}
		return binding;
	};
	var domPublic = implementation.domPublic = [];
	for (var field in implementation.prototype) {
		if (/^(_|dom)/.test(field)) continue;
		domPublic.push(field);
	}
//	if (window[this.name] !== this) {
		var domPrototype = this.prototype;
		hide(domPrototype, domPublic);
		domPublic.forEach(function(field) { bindProperty(domPrototype, implementation, field); });
//	}
	return implementation.getStorage;
}

for (var name in interfacesByName) {
	var ifSpec = interfacesByName[name];
	var domInterface = new DOMInterface(name);
	domSystem[name] = domInterface;
	if (!window[name]) window[name] = domInterface;
	else domInterface.prototype = window[name].prototype;

	var baseName = ifSpec.base;
	if (baseName) domInterface.baseInterface = domSystem[baseName];
}

// TODO tidy-up the DOMInterface utils into a class
function lookupDOMInterface(node) {
	var rule = interfaceRulesTree;
	while ("string" != typeof rule) {
		var rc = rule._test(node);
		if (rc != null) rule = rule[rc] || rule._default || "";
		else rule = rule._null || "";
	}
	return rule;
}
function attachDOMInterfaces(node) {
	var ifName = lookupDOMInterface(node);
	var domInterface = domSystem[ifName];
	if (!domInterface) {
		logger.error("attachDOMInterfaces: Could not find DOMInterface for nodeType: " + node.nodeType);
		throw "Error attaching DOMInterfaces";
	}
	if (domInterface === window[ifName] && !node.slabID) domInterface.attach(node); // FIXME nodeManager.hasInterface(node)
	return node;
}
function detachDOMInterfaces(node) { // MUST be called with nodeManager.releaseNodesByType(nodeType, detachDOMInterfaces)
	var ifName = lookupDOMInterface(node);
	var domInterface = domSystem[ifName];
	if (!domInterface) {
		logger.error("detachDOMInterfaces: Could not find DOMInterface for nodeType: " + node.nodeType);
		throw "Error detaching DOMInterfaces";
	}
	domInterface.detach(node);
}

function detachDOMInterfacesByNodeType(nodeType) {
	nodeManager.releaseNodesByType(nodeType, detachDOMInterfaces);
}

var timerId = null,
	readyState = "uninitialized",
	domWalker = null,
	trigger = "head";

var readyStateLookup = {
	"uninitialized": false,
	"loading": false,
	"interactive": false,
	"loaded": true,
	"complete": true
}
function checkTrigger() {
	if (trigger == "head") return (document.body) ? true : false;
	else return readyStateLookup[document.readyState] || false;
}
function init() {
	if (null == document.readyState) { // Mozilla
		document.readyState = "loading";	
		window.addEventListener("DOMContentLoaded", function(event) { document.readyState = "loaded"; }, true);
		window.addEventListener("load", function(event) { if (event.target == document || event.target == window) document.readyState = "complete"; }, true);
	}
	
	if (window.addEventListener) window.addEventListener("unload", exit, false);
	if (window.attachEvent) window.attachEvent("onunload", exit);	

	if (trigger == "head" && checkTrigger()) trigger == "body"; // FIXME
	timerId = window.setTimeout(onprogress, 0); // push into queue
}

function exit() { // FIXME
logger.debug("Beginning exit process");
	detachDOMInterfacesByNodeType(Node.ELEMENT_NODE);
	detachDOMInterfacesByNodeType(Node.DOCUMENT_NODE);
	detachDOMInterfacesByNodeType(0); // Window

logger.debug("DOMInterfaces detached");

	if (window.removeEventListener) window.removeEventListener("unload", exit, false);
	if (window.detachEvent) window.detachEvent("onunload", exit);
logger.debug("Finished exit process");
}

function onprogress() {
	if (readyState == "uninitialized" && checkTrigger() || readyState != "uninitialized") _init();
	if (readyState != "complete") timerId = window.setTimeout(onprogress, 50); // FIXME timeout shouldn't be hard-coded
}

var _initializing = false; // guard against re-entrancy
function _init() {
	if (_initializing) {
		logger.warn("Reentrancy in domSystem initialization.");
		return;
	}
	if (readyState == "complete") {
		logger.warn("domSystem initialization requested after complete");
		return;
	}
	
	_initializing = true;
	try { __init(); }
	catch(error) { logger.error(error.message); }
	_initializing = false;	
}

function manualInit() {
	if (readyState != "uninitialized") {
		logger.warn("Manual domSystem initialization requested after automatic start");
		return;		
	}
	_init();
}

function __init() {
	MAIN: switch (readyState) { // NOTE all these branches can fall-thru when they result in a state transition
		case "uninitialized":
			;;;logger.debug("initializing");
/*
			attachDOMInterfaces(window); // force attach
			attachDOMInterfaces(document); // force attach
*/
			readyState = "loading";
		case "loading":
			;;;logger.debug("loading");
			// FIXME if document.readyState is updated while this thread is running then there could be a failure here.
			switch (document.readyState) {
				case "loaded": case "complete":
					logger.debug("Dispatching compat DOMContentLoaded event");
					var event = document.createEvent("Event");
					event.initEvent("DOMContentLoaded", true, true);
					document.dispatchEvent(event);
					readyState = "loaded";
					break;
				default: break MAIN;
			}
		case "loaded":
			if (document.readyState != "complete") break MAIN;
			readyState = "complete";
	}

	// NOTE it is an error if we don't get to this point
	;;;logger.debug("Dispatching compat progress event");
	var event = document.createEvent("Event");
	event.initEvent("progress", true, true);
	document.dispatchEvent(event);
	if (readyState == "complete") {
		;;;logger.debug("Dispatching compat load event");
		var event = document.createEvent("Event");
		event.initEvent("load", true, true);
		document.dispatchEvent(event);
	}
}

function wrap(dest, fields) {
	for (var n=fields.length, i=0; i<n; i++) {
		var name = fields[i];
		var _name = "_" + name;
		dest[_name] = dest[name];
		dest[name] = function() {
			var node = this[_name]();
			domSystem.attach(node);
			return node;
		}
	}
}


init();

Object.copy(domSystem, { // FIXME this is a complete hack
	addBinding: function(name, spec) { return domSystem[name].addBinding(spec); },
	bindInterface: bind,
	releaseInterface: release,
	hideInterface: hide,
	restoreInterface: restore,
	wrapInterface: wrap,
	attach: attachDOMInterfaces,
	initialize: manualInit
});

return domSystem;

})();

]]>
</script>
</head>
</html>
