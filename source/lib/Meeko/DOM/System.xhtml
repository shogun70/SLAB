<?xml version="1.0"?>
<?xpl-require href="../ECMAScript5.xhtml"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<script type="text/javascript">
<![CDATA[

(function() { // A few cross-browser fixes

if (!document.parentWindow) document.parentWindow = window;

//	document.documentURI for a range of browsers
var _documentURI = document.documentURI || document.baseURI || document.URL || document.url || document.location;
if (!document.documentURI) document.documentURI = _documentURI;

// make visible window["[[DOMDocument]]"], etc in Safari-2
document.createElement("select").options;
document.createTextNode("text");
document.createAttribute("attribute");

var safari2Prototypes = {
	Node: "[[DOMNode.prototype]]",
	Text: "[[DOMText.prototype]]",
	Document: "[[DOMDocument.prototype]]",
	Element: "[[DOMElement.prototype]]",
	Event: "[[DOMEvent.prototype]]"
}

for (var name in safari2Prototypes) {
	var proto = safari2Prototypes[name];
	if (!window[proto]) continue;
	if (!window[name]) window[name] = function() {};
	window[name].prototype = window[proto];
}

})();

Meeko.stuff.domSystem = (function() {

var domSystem = {};

var interfaceTable = [
//	{ name: "Node" },
	{ name: "Window", nodeType: 0 }, // NOTE treated as a node for internal purposes
	{ name: "Text", base: "Node", nodeType: 3 }, // Node.TEXT_NODE },
	{ name: "Document", base: "Node", nodeType: 9 }, // Node.DOCUMENT_NODE },
	{ name: "HTMLDocument", base: "Document", nodeType: 9 }, // Node.DOCUMENT_NODE },
	{ name: "Element", base: "Node", nodeType: 1 }, // Node.ELEMENT_NODE },
	{ name: "HTMLElement", base: "Element", nodeType: 1 }, // Node.ELEMENT_NODE },
	{ name: "HTMLLinkElement", element: "link", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE },
	{ name: "HTMLStyleElement", element: "style", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE },
	{ name: "HTMLFormElement", element: "form", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLSelectElement", element: "select", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLInputElement", element: "input", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLTableElement", element: "table", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLTableSectionElement", element: "thead, tfoot, tbody", base: "HTMLElement", nodeType: 1 }, // Node.ELEMENT_NODE }
	{ name: "HTMLTableRowElement", element: "tr", base: "HTMLElement", nodeType: 1 } // Node.ELEMENT_NODE }
];

var interfacesByName = {};
Object.forEach (interfaceTable, function(row) {
	interfacesByName[row.name] = row;
})

var interfaceInheritanceChains = {};
for (var name in interfacesByName) {
	interfaceInheritanceChains[name] = [];
	var chain = interfaceInheritanceChains[name];
	do {
		chain.unshift(name);
		var ifSpec = interfacesByName[name];
		name = (ifSpec) ? ifSpec.base : null;
	} while (name);
}

function getLocalName(element) {
	return (element.localName) ? element.localName : element.tagName.replace(element.prefix+":", "");	
}
var htmlElementRulesTree = { // TODO this tree should be generated from interfaceTable[]
	_test: function(node) { return getLocalName(node).toLowerCase(); }, // FIXME toLowerCase() should only apply to HTML elts
	"link": "HTMLLinkElement",
	"style": "HTMLStyleElement",
	"form": "HTMLFormElement",
	"select": "HTMLSelectElement",
	"input": "HTMLInputElement",
	"table": "HTMLTableElement",
	"thead": "HTMLTableSectionElement",
	"tfoot": "HTMLTableSectionElement",
	"tbody": "HTMLTableSectionElement",
	"tr": "HTMLTableRowElement",
	_default: "HTMLElement"
}

var interfaceRulesTree = {
	_test: function(node) { return (node != window) ? node.nodeType : 0; },
	0: "Window",
	1: { // Node.ELEMENT_NODE
		_test: function(node) { return node.namespaceURI },
		"http://www.w3.org/1999/xhtml" : htmlElementRulesTree,
		_null: htmlElementRulesTree,
		_default: "Element"
	},
	9: { // Node.DOCUMENT_NODE
		_test: function(node) { return node.namespaceURI },
		"http://www.w3.org/1999/xhtml" : "HTMLDocument",
		_null: "HTMLDocument",
		_default: "Document"
	}
}

var nodeTable = new Array(13);
for (var i=0; i<13; i++) {
	nodeTable[i] = [];
}
var nodeManager = {};
nodeManager.getStorage = function(node) {
	return node.slabID;
}
nodeManager.addNode = function(node, callback, context) {
	if (this.getStorage(node)) { // FIXME why?
		// logger.debug("Failure in addNode(): node already being managed " + node.tagName);
		return false;
	}
	var nodeType = (node != window) ? node.nodeType : 0;
	var nodeList = nodeTable[nodeType];
	var index = nodeList.length;
	nodeList.push(node);
	var slabID = "slab__" + nodeType + "_" + index;
	var store = {
		__id__ : slabID,
		valueOf: function() { return this.__id__ },
		toString: function() { return this.__id__ }
	};
	node.slabID = store;
	if (callback) callback.call(context, node);
	return true;
}
nodeManager.releaseNodesByType = function(type, callback, context) {
	var nodeList = nodeTable[type];
	for (var i=nodeList.length-1; i>=0; i--) {
		var node = nodeList[i];
		if (callback) callback.call(context, node);
		delete nodeList[i];
		var store = node.slabID;
		node.slabID = null;
	}
}

/*
elementBinding = function() {}
	prototype: {},
	implementation: function() {},
		prototype: {},
	handlers: []
*/


var privateKey = Math.random();

function bind(dest, source, fields, override) {
	function _bind(dst, src, name, over) {
		if (src[name] == null) return;
		if (!over && (dst.hasOwnProperty && dst.hasOwnProperty(name) || dst[name] != null)) return;
		if ("function" == typeof src[name]) dst[name] = function() { return src[name].apply(src, arguments); };
		else if (dst.__defineGetter__) dst.__defineGetter__(name, function() { return src[name]; });
		else dst[name] = src[name];
	}
	if (fields && fields.length) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_bind(dest, source, name, override);
		}
	}
	else {
		for (var name in source) _bind(dest, source, name, override);
	}
	return dest;
}

function release(dest, source, fields) {
	function _release(dst, src, name) {
		if (dst[name] == null) return;
		dst[name] = null;
	}
	if (fields && fields.length) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_release(dest, source, name);
		}
	}
	else {
		for (var name in source) _release(dest, source, name);
	}
	return dest;
}

function hide(node, fields) {
	for (var n=fields.length, i=0; i<n; i++) {
		var name = fields[i];
		var _name = "_" + name;
		if (node[name]) {
			node[_name] = node[name];
			// delete node[name];
			node[name] = null;
		}
	}
}

function restore(node, fields) {
	for (var n=fields.length, i=0; i<n; i++) {
		var name = fields[i];
		var _name = "_" + name;
		if (node[_name]) {
			node[name] = node[_name];
			// delete node[name];
			node[_name] = null;
		}
	}
}

var incompleteBindings = []; // domBindings with xblReadyState() != "complete"

/*
 DOMBinding is a ClassFactory for dom-binding classes. Usage:
   var HTMLElement = new DOMBinding("HTMLElement");
 The DOMBinding class is then attached to a node with:
   HTMLElement.attach(node);
*/
var DOMBinding = function(name) {
	this.name = name;
	this.prototype = {};
	this.interfaces = [];
	this.implementation = function(node) {};
}
DOMBinding.prototype.xblRequired = function(node) {
	for (var n=this.interfaces.length, i=0; i<n; i++) {
		var ifaceSpec = this.interfaces[i];
		if (ifaceSpec.xblRequired && ifaceSpec.xblRequired(node)) return true;
	}
	if (this.baseBinding) return this.baseBinding.xblRequired(node);
	else return false;
}
DOMBinding.prototype.attach = function(node) {
	if (this.baseBinding) this.baseBinding.attach(node);
	Object.copy(node, this.prototype); // TODO optimize
	var internal = new this.implementation(node);
	for (var n=this.interfaces.length, i=0; i<n; i++) {
		var ifaceSpec = this.interfaces[i];
		var iface = new ifaceSpec(node);
		internal[i] = iface;
		if (iface.xblReadyState && iface.xblReadyState() != "complete") incompleteBindings.push(iface);
	}
	var ifName = "_" + this.name;
	nodeManager.getStorage(node)[ifName] = internal;
}
DOMBinding.prototype.detach = function(node) { // FIXME
	var ifName = "_" + this.name;
	var store = nodeManager.getStorage(node);
	var internal = store[ifName];
	// delete node[ifName]
	store[ifName] = null;
	if (!internal) {
		logger.warn("Failure removing non-existant "+this.name+" interface from "+node.tagName);
		return;
	}
	for (var n=this.interfaces.length, i=n-1; i>=0; i--) {
		var iface = internal[i];
		if (iface && iface.xblDestroy) iface.xblDestroy(node);
		internal[i] = null;
	}
	// FIXME Object.uncopy(node, this.prototype);
	for (var field in this.prototype) {
		if (node[field] === this.prototype[field]) node[field] = null;
	}
	if (this.baseBinding) this.baseBinding.detach(node);
}
DOMBinding.prototype.addImplementation = function(impl) {
	this.interfaces.push(impl);
	var ifName = "_" + this.name;
	var index = this.interfaces.length - 1;
	return function(node) {
		var store = nodeManager.getStorage(node);
		if (!store) return;
		var domBinding = store[ifName];
		if (!domBinding) return;
		return domBinding[index];
	};
}

for (var name in interfacesByName) {
	var ifSpec = interfacesByName[name];
	var domBinding = new DOMBinding(name);
	domSystem[name] = domBinding;
	if (!window[name]) window[name] = domBinding;
	if (!window[name].prototype) window[name].prototype = domBinding.prototype;
	
	var baseName = ifSpec.base;
	if (baseName) domBinding.baseBinding = domSystem[baseName];
}

// TODO tidy-up the DOMBinding utils into a class
function lookupDOMBinding(node) {
	var rule = interfaceRulesTree;
	while ("string" != typeof rule) {
		var rc = rule._test(node);
		if (rc != null) rule = rule[rc] || rule._default || "";
		else rule = rule._null || "";
	}
	return domSystem[rule];
}
var filterDOMBindings = {
	acceptNode: function(node) {
		var domBinding = lookupDOMBinding(node);
		if (!domBinding) {
			logger.warn("filterDOMBindings: Could not find DOMBinding for nodeType: " + node.nodeType);
			return NodeFilter.FILTER_REJECT;
		}
		return (domBinding.xblRequired(node)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
	}
}
function attachDOMBindings(node) {
	var domBinding = lookupDOMBinding(node);
	if (!domBinding) {
		logger.error("attachDOMBindings: Could not find DOMBinding for nodeType: " + node.nodeType);
		throw "Error attaching DOMBindings";
	}
	if (nodeManager.addNode(node)) domBinding.attach(node); // FIXME assumes that if addNode fails then bindings are already attached
	return node;
}
function detachDOMBindings(node) { // MUST be called with nodeManager.releaseNodesByType(nodeType, detachDOMBindings)
	var domBinding = lookupDOMBinding(node);
	if (!domBinding) {
		logger.error("detachDOMBindings: Could not find DOMBinding for nodeType: " + node.nodeType);
		throw "Error detaching DOMBindings";
	}
	domBinding.detach(node);
}

function detachDOMBindingsByNodeType(nodeType) {
	nodeManager.releaseNodesByType(nodeType, detachDOMBindings);
}

var timerId = null,
	readyState = "uninitialized",
	domWalker = null;

function init() {
	if (null == document.readyState) { // Mozilla
		document.readyState = "loading";	
		document.addEventListener("DOMContentLoaded", function(event) { document.readyState = "loaded"; }, true);
		window.addEventListener("load", function(event) { if (event.target == document || event.target == window) document.readyState = "complete"; }, true);
	}
	
	if (window.addEventListener) window.addEventListener("unload", exit, true);
	if (window.attachEvent) window.attachEvent("onunload", exit);	

	onprogress();
}

function exit() { // FIXME
logger.debug("Beginning exit process");
	detachDOMBindingsByNodeType(Node.ELEMENT_NODE);
	detachDOMBindingsByNodeType(Node.DOCUMENT_NODE);
	detachDOMBindingsByNodeType(0); // Window

logger.debug("DOMBindings detached");

	if (window.removeEventListener) window.removeEventListener("unload", exit, false);
	if (window.detachEvent) window.detachEvent("onunload", exit);
logger.debug("Finished exit process");
}

function onprogress() {
	if (readyState == "uninitialized" && document.body || readyState != "uninitialized") _init();
	if (readyState != "complete") timerId = window.setTimeout(onprogress, 50);
}

var _initializing = false; // guard against re-entrancy
function _init() {
	if (_initializing) {
		logger.warn("Reentrancy in domSystem initialization.");
		return;
	}
	if (readyState == "complete") {
		logger.warn("domSystem initialization requested after complete");
		return;
	}
	_initializing = true;
	try { __init(); }
	catch(error) { logger.error(error.message); }
	_initializing = false;	
}

function manualInit() {
	if (readyState != "uninitialized") {
		logger.warn("Manual domSystem initialization requested after automatic start");
		return;		
	}
	_init();
}

function __init() {
	MAIN: switch (readyState) { // NOTE all these branches can fall-thru when they result in a state transition
		case "uninitialized":
;;;logger.debug("initializing");
			attachDOMBindings(window); // force attach
			attachDOMBindings(document); // force attach
			window.addEventListener("DOMNodeInserted", function(event) {
				if (event.target.nodeType == 1) { // Node.ELEMENT_NODE) {
logger.debug("DOMNodeInserted");
					var localWalker = document._createTreeWalker(event.target, NodeFilter.SHOW_ELEMENT, filterDOMBindings, false);
					localWalker.forEach(attachDOMBindings); // FIXME some elements will already have bindings applied
				}
			}, true);
			domWalker = document._createTreeWalker(document.documentElement, NodeFilter.SHOW_ELEMENT, filterDOMBindings, false);
			readyState = "loading";
		case "loading":
;;;logger.debug("loading");
			domWalker.forEach(attachDOMBindings);
			// FIXME if document.readyState is updated while this thread is running then there could be a failure here.
			switch (document.readyState) {
				case "loaded": case "interactive": case "complete":
					logger.debug("Dispatching compat DOMContentLoaded event");
					var event = document.createEvent("Event");
					event.initEvent("DOMContentLoaded", true, true);
					document.dispatchEvent(event);
					readyState = "loaded";
					break;
				default: break MAIN;
			}
		case "loaded":
;;;logger.debug("loaded");
			for (var i=incompleteBindings.length-1; i>=0; i--) {
				if ("complete" == incompleteBindings[i].xblReadyState()) incompleteBindings.splice(i,1);
			}
			if (incompleteBindings.length) break MAIN;
			readyState = "complete";
;;;logger.debug("complete");
	}
	
	// NOTE it is an error if we don't get to this point
	logger.debug("Dispatching compat progress event");
	var event = document.createEvent("Event");
	event.initEvent("progress", true, true);
	document.dispatchEvent(event);
	if (readyState == "complete") {
		logger.debug("Dispatching compat load event");
		var event = document.createEvent("Event");
		event.initEvent("load", true, true);
		document.dispatchEvent(event);
	}
}

function wrap(dest, fields) {
	for (var n=fields.length, i=0; i<n; i++) {
		var name = fields[i];
		var _name = "_" + name;
		dest[_name] = dest[name];
		dest[name] = function() {
			var node = this[_name]();
			domSystem.attach(node);
			return node;
		}
	}
}


init();

Object.copy(domSystem, { // FIXME this is a complete hack
	addImplementation: function(name, impl) { return domSystem[name].addImplementation(impl); },
	bindInterface: bind,
	releaseInterface: release,
	hideInterface: hide,
	restoreInterface: restore,
	wrapInterface: wrap,
	attach: attachDOMBindings,
	initialize: manualInit,
	document: {} // FIXME implement this
});

var Traversal = function(target) {
	if (null == target) return null; // TODO throw ??
	if (this == window) return arguments.callee.getInterface(target);
	else arguments.callee.prototype.xblCreate.call(this, target);
}
Traversal.getInterface = domSystem.addImplementation("Document", Traversal);
Traversal.methods = ["createTreeWalker", "createNodeIterator"];
Traversal.prototype.xblCreate = function(target) {
	this.target = target;
	var xblPublic = Traversal.methods;
	domSystem.hideInterface(target, xblPublic);
	domSystem.bindInterface(target, this, xblPublic, true); // NOTE override on W3C systems
}
Traversal.prototype.xblDestroy = function(target) {
	this.target = null;
	var xblPublic = Traversal.methods;
	domSystem.releaseInterface(target, this, xblPublic, true);
	domSystem.restoreInterface(target, xblPublic);
}
Traversal._createInterface = function(fields) {
	var iface = function() {};
	for (var n=fields.length, i=0; i<n; i++) {
		var name = fields[i];
		iface.prototype[name] = new Function('var node = this.baseBinding["' + name + '"](); if (node) { this.currentNode = node; Meeko.stuff.domSystem.attach(node); } return node;');
	}
	return iface;
}

Traversal.TreeWalker = Traversal._createInterface(["firstChild", "lastChild", "parentNode", "nextSibling", "previousSibling", "nextNode", "previousNode"]);
Traversal.TreeWalker.prototype.forEach = function(callback, context) { return this.baseBinding.forEach.call(this, callback, context); }
Traversal.NodeIterator = Traversal._createInterface(["nextNode", "previousNode"]);
Traversal.NodeIterator.prototype.forEach = function(callback, context) { return this.baseBinding.forEach.call(this, callback, context); }

Traversal.prototype.createTreeWalker = function(root, whatToShow, filter, entityReferenceExpansion) {
	var _filter = {};
	_filter.baseBinding = filter;
	_filter.acceptNode = function(node) {
		var lastDocumentNode = domWalker.currentNode;
		if (lastDocumentNode === node || lastDocumentNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_PRECEDING) {
			if (this.baseBinding) return this.baseBinding.acceptNode(node);
			else return NodeFilter.FILTER_ACCEPT;
		}
		else return NodeFilter.FILTER_REJECT;
	}
	var iter = new Traversal.TreeWalker();
	iter.baseBinding = document._createTreeWalker(root, whatToShow, _filter, entityReferenceExpansion);
	return iter;
}
Traversal.prototype.createNodeIterator = function(root, whatToShow, filter, entityReferenceExpansion) {
	var _filter = {};
	_filter.baseBinding = filter;
	_filter.acceptNode = function(node) {
		var lastDocumentNode = domWalker.currentNode;
		var cmp = (lastDocumentNode.compareDocumentPosition) ?
			lastDocumentNode.compareDocumentPosition(node) :
			Element.prototype.compareDocumentPosition.call(lastDocumentNode, node);
		if (lastDocumentNode === node || cmp & Node.DOCUMENT_POSITION_PRECEDING) {
			if (this.baseBinding) return this.baseBinding.acceptNode(node);
			else return NodeFilter.FILTER_ACCEPT;
		}
		else return NodeFilter.FILTER_REJECT;
	}
	var iter = new Traversal.NodeIterator();
	iter.baseBinding = document._createNodeIterator(root, whatToShow, _filter, entityReferenceExpansion);
	return iter;
}

/*
 HTMLCollection fixes
 Ideally we want to remove the whole native HTMLCollection interface 
 and provide access through the programmed iface.
 This allows us to prevent access via array ([]) notation. 
 Unfortunately this approach doesn't work on Safari-3, 
 so we override the prototype methods as well. 
*/
if (window.NodeList) {
NodeList.prototype._item = NodeList.prototype.item;
NodeList.prototype.item = function(index) { return attachDOMBindings(this[index]); }
}
if (window.HTMLCollection) {
HTMLCollection.prototype._item = HTMLCollection.prototype.item;
HTMLCollection.prototype.item = function(index) { return attachDOMBindings(this[index]); }
HTMLCollection.prototype._namedItem = HTMLCollection.prototype.namedItem;
HTMLCollection.prototype.namedItem = function(name) { return attachDOMBindings(this[name]); }
}

domSystem.NodeList = {};
domSystem.HTMLCollection = {};
with (domSystem) {
NodeList.fix = function(base) {
	var coll = {};
	coll._base = base;
	coll.item = function(index) { 
		var item = this._base[index]; 
		if (item) attachDOMBindings(item);
		return item;
	}
	Object.defineProperty(coll, "length", { get: function() { return this._base.length; } });
	return coll;
}
NodeList.fixInterface = function(target, field) {
	var base = target[field]; // base points to the native interface
	target["_"+field] = base; 
	var coll = this.fix(base);
	Object.defineProperty(target, field, { value: coll });
}
HTMLCollection.fix = function(base) {
	var coll = {};
	coll._base = base;
	coll.item = function(index) { 
		var item = this._base[index]; 
		if (item) attachDOMBindings(item);
		return item;
	}
	coll.namedItem = function(name) { 
		var item = this._base[name]; 
		if (item) attachDOMBindings(item);
		return item;
	}
	Object.defineProperty(coll, "length", { get: function() { return this._base.length; } });
	return coll;
}
HTMLCollection.fixInterface = function(target, field) {
	var base = target[field]; // base points to the native interface
	target["_"+field] = base; 
	var coll = this.fix(base);
	Object.defineProperty(target, field, { value: coll });
}
HTMLCollection.addInterface = function(target, field, filter) {
	var coll = {};
	coll._target = target,
	coll.item = function(index) {
		var i = -1, node = this._target.firstChild;
		while (node) {
			if (node.nodeType == 1) { // Node.ELEMENT_NODE
				if (!filter || filter(node) == 1) i++; // NodeFilter.FILTER_ACCEPT
				if (index == i) return attachDOMBindings(node);
			}
			node = node.nextSibling;
		}
		return null;
	}
	Object.defineProperty(coll, "length", { get: function() {
		var i = 0, node = this._target.firstChild;
		while (node) {
			if (node.nodeType == 1) { // Node.ELEMENT_NODE
				if (!filter || filter(node) == 1) i++; // NodeFilter.FILTER_ACCEPT
			}
			node = node.nextSibling;
		}
		return i;						
	} });
	Object.defineProperty(target, field, { value: coll });
}
document.__getElementById = document.getElementById;
document.getElementById = function(id) {
	var elt = this.__getElementById(id);
	if (!elt) return null;
	if (elt.attributes['id'].nodeValue == id) return elt;
	// NOTE if getElementById is effectively getElementByIdOrName then assume getElementsByName is getElementsByIdOrName
	var list = this.__getElementsByName(id);
	for (var n=list.length, i=0; i<n; i++) {
		elt = list.item(i);
		if (elt.attributes['id'].nodeValue == id) return elt;
	}
	return null;
}
document.__getElementsByName = document.getElementsByName;
document.getElementsByName = function(name) { // NOTE this returns a "StaticNodeList" rather than a NodeList
	var coll = Array.filter(this.__getElementsByName(name), function(elt) { return (elt.attributes['name'].nodeValue == name); })
	coll.item = function(index) { return this[index]; }
	return coll;
}
Document._attach = Document.attach;
Document._detach = Document.detach;
Document.attach = function(target) {
	this._attach(target);
	target._getElementById = target.getElementById;
	target.getElementById = function(id) {
		var elt = this._getElementById(id);
		if (elt) attachDOMBindings(elt);
		return elt;
	}
/*
	target._getElementsByTagName = target.getElementsByTagName;
	target.getElementsByTagName = function(tagName) {
		var coll = this._getElementsByTagName(tagName);
		return NodeList.fix(coll);
	}
*/
}
Document.detach = function(target) {
	target.getElementById = target.__getElementById;
	target._getElementById = null
	target.__getElementById = null;
/*
	target.getElementsByTagName = target._getElementsByTagName;
	target._getElementsByTagName = null
*/
	this._detach(target);
}
HTMLDocument._attach = HTMLDocument.attach;
HTMLDocument._detach = HTMLDocument.detach;
HTMLDocument.attach = function(target) {
	this._attach(target);
	target._getElementsByName = target.getElementsByName;
	target.getElementsByName = function(name) {
		var coll = this._getElementsByName(name);
		return NodeList.fix(coll);
	}
	target._querySelector = target.querySelector;
	target.querySelector = function(name) {
		var elt = this._querySelector(name);
		if (elt) attachDOMBindings(elt);
		return elt;
	}
	target._querySelectorAll = target.querySelectorAll;
	target.querySelectorAll = function(name) {
		var coll = this._querySelectorAll(name);
		return NodeList.fix(coll);
	}
}
HTMLDocument.detach = function(target) {
	target.getElementsByName = target.__getElementsByName;
	target._getElementsByName = null
	target.__getElementsByName = null;
	target.querySelector = target._querySelector;
	target._querySelector = null;
	target.querySelectorAll = target._querySelectorAll;
	target._querySelectorAll = null;
	this._detach(target);
}
HTMLElement._attach = HTMLElement.attach;
HTMLElement._detach = HTMLElement.detach;
HTMLElement.attach = function(target) {
	this._attach(target);
	if (target.children) HTMLCollection.fixInterface(target, "children");
	else HTMLCollection.addInterface(target, "children");
}
HTMLElement.detach = function(target) {
	target.children = target._children;
	target._children = null;
	this._detach(target);
}

HTMLFormElement._attach = HTMLFormElement.attach;
HTMLFormElement._detach = HTMLFormElement.detach;
HTMLFormElement.attach = function(target) {
	this._attach(target);
	HTMLCollection.fixInterface(target, "elements");
}
HTMLFormElement._detach = function(target) {
	target.elements = target._elements;
	target._elements = null;
	this._detach(target);
}
HTMLSelectElement._attach = HTMLSelectElement.attach;
HTMLSelectElement._detach = HTMLSelectElement.detach;
HTMLSelectElement.attach = function(target) {
	this._attach(target);
	HTMLCollection.fixInterface(target, "options");
	if (target.form) attachDOMBindings(target.form);
}
HTMLSelectElement._detach = function(target) {
	target.options = target._options;
	target._options = null;
	this._detach(target);
}
HTMLInputElement._attach = HTMLInputElement.attach;
HTMLInputElement._detach = HTMLInputElement.detach;
HTMLInputElement.attach = function(target) {
	this._attach(target);
	if (target.form) attachDOMBindings(target.form);
}
HTMLInputElement._detach = function(target) {
	this._detach(target);
}
HTMLTableElement._attach = HTMLTableElement.attach;
HTMLTableElement._detach = HTMLTableElement.detach;
HTMLTableElement.attach = function(target) {
	this._attach(target);
	if (target.tHead) attachDOMBindings(target.tHead);
	if (target.tFoot) attachDOMBindings(target.tFoot);
	HTMLCollection.fixInterface(target, "tBodies");
	HTMLCollection.fixInterface(target, "rows");
}
HTMLTableElement._detach = function(target) {
	target.tBodies = target._tBodies;
	target._tBodies = null;
	target.rows = target._rows;
	target._rows = null;
	this._detach(target);
}
HTMLTableSectionElement._attach = HTMLTableSectionElement.attach;
HTMLTableSectionElement._detach = HTMLTableSectionElement.detach;
HTMLTableSectionElement.attach = function(target) {
	this._attach(target);
	HTMLCollection.fixInterface(target, "rows");
}
HTMLTableSectionElement._detach = function(target) {
	target.rows = target._rows;
	target._rows = null;
	this._detach(target);
}
HTMLTableRowElement._attach = HTMLTableRowElement.attach;
HTMLTableRowElement._detach = HTMLTableRowElement.detach;
HTMLTableRowElement.attach = function(target) {
	this._attach(target);
	HTMLCollection.fixInterface(target, "cells");
}
HTMLTableRowElement._detach = function(target) {
	target.cells = target._cells;
	target._cells = null;
	this._detach(target);
}
}

return domSystem;

})();

]]>
</script>
</head>
</html>
