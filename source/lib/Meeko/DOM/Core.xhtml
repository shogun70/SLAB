<?xml version="1.0"?>
<html>
<head>
<script type="text/html" src="../ECMAScript5.xhtml"></script>
<script type="text/html" src="../DOM/System.xhtml"></script>
<script>
<![CDATA[

Meeko.stuff.xplSystem.createNamespace("Meeko.DOM.Core");
Meeko.DOM.Core = (function() {
	
var Node = function() {};
Node.ELEMENT_NODE = 1;
Node.ATTRIBUTE_NODE = 2;
Node.TEXT_NODE = 3;
Node.CDATA_SECTION_NODE = 4;
Node.ENTITY_REFERENCE_NODE = 5;
Node.ENTITY_NODE = 6;
Node.PROCESSING_INSTRUCTION_NODE = 7;
Node.COMMENT_NODE = 8;
Node.DOCUMENT_NODE = 9;
Node.DOCUMENT_TYPE_NODE = 10;
Node.DOCUMENT_FRAGMENT_NODE = 11;
Node.NOTATION_NODE = 12;

Node.DOCUMENT_POSITION_DISCONNECTED = 0x01;
Node.DOCUMENT_POSITION_PRECEDING = 0x02;
Node.DOCUMENT_POSITION_FOLLOWING = 0x04;
Node.DOCUMENT_POSITION_CONTAINS = 0x08;
Node.DOCUMENT_POSITION_CONTAINED_BY = 0x10;
Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

var Text = function() {};

var Document = function() {};

Document.prototype.importNode = function(node, bDeep) {
	// FIXME need to check whether importing from xml or html document
	// and make use of attr.specifed, style.cssText, etc
	var document = this;
	var tree;
	switch (node.nodeType) {
		case Node.ELEMENT_NODE:
			tree = document.createElement(node.nodeName);
			var attrs = node.attributes;
			for (var i=0; i<attrs.length; i++) {
				var attr = attrs[i];
				tree.setAttribute(attr.nodeName, attr.nodeValue);
			};
			var children = node.childNodes;
			if (bDeep) for (var i=0; i<children.length; i++) {
				var child = children[i];
				tree.appendChild(document.importNode(child, true));
			};
			break;
		case Node.CDATA_SECTION_NODE:
		case Node.TEXT_NODE:
			tree = document.createTextNode(node.nodeValue);
			break;
	}
	return tree;
}

var Element = function() {}

if (!document.documentElement.compareDocumentPosition && document.documentElement.contains) {

Element.prototype.compareDocumentPosition = function(node) {
	if (node == undefined) return 0x01; // Node.DOCUMENT_POSITION_DISCONNECTED;
	if (this === node) return 0;
	if (node.sourceIndex <= 0 || this.sourceIndex <= 0) return 0x01; // Node.DOCUMENT_POSITION_DISCONNECTED;
	if (node.contains(this)) return 0x0A; // Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;
	if (this.contains(node)) return 0x14; // Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING;
	if (node.sourceIndex < this.sourceIndex) return 0x02; // Node.DOCUMENT_POSITION_PRECEDING;
	if (node.sourceIndex > this.sourceIndex) return 0x04; // Node.DOCUMENT_POSITION_FOLLOWING;
	return 0x01; // Node.DOCUMENT_POSITION_DISCONNECTED;
}

}

var DOMException = function() {};

DOMException.INDEX_SIZE_ERR = 1;
DOMException.DOMSTRING_SIZE_ERR = 2;
DOMException.HIERARCHY_REQUEST_ERR = 3;
DOMException.WRONG_DOCUMENT_ERR = 4;
DOMException.INVALID_CHARACTER_ERR = 5;
DOMException.NO_DATA_ALLOWED_ERR = 6;
DOMException.NO_MODIFICATION_ALLOWED_ERR = 7;
DOMException.NOT_FOUND_ERR = 8;
DOMException.NOT_SUPPORTED_ERR = 9;
DOMException.INUSE_ATTRIBUTE_ERR = 10;
DOMException.INVALID_STATE_ERR = 11;
DOMException.SYNTAX_ERR = 12;
DOMException.INVALID_MODIFICATION_ERR = 13;
DOMException.NAMESPACE_ERR = 14;
DOMException.INVALID_ACCESS_ERR = 15;
DOMException.VALIDATION_ERR = 16;
DOMException.TYPE_MISMATCH_ERR = 17;


var DOMTokenList = function(getter, setter) { // TODO parameter checking
	this._getText = getter;
	this._setText = setter;
	this.valueOf = getter;
	this.toString = getter;
	Object.defineProperty(this, "length", {
		"get": function() { return this._getTokens().length; }
	})
};
DOMTokenList.prototype.xblDestroy = function() { // FIXME is this needed??
	this.valueOf = null;
	this.toString = null;
	this._getText = null;
	this._setText = null;
	this.length = null;
}
DOMTokenList.prototype.item = function(index) {
	return this._getTokens()[index];
}
DOMTokenList.prototype.contains = function(token) {
	var tokens = this._getTokens();
	return (tokens.indexOf(token) >= 0);
}
DOMTokenList.prototype.add = function(token) {
	if (this.contains(token)) return;
	var text = this._getText();
	var n = text.length;
	if (n && text.charAt(n-1) != " ") text += " " + token;
	else text += token;
	this._setText(text);
}
DOMTokenList.prototype.remove = function(token) {
	var text = this._getText(), tmp = text, result = "";
	var rex = /^(\s*)(\w+)\b(\s*)/;
	var i = 0; // non-matching-token counter
	var lastMatch = false;
	result = text.replace(/(\s*)\b(\w+)\b/g, function($0, $1, $2) {
		var tmp;
		if ($2 == token) {
			tmp = "";
			lastMatch = true;
		}
		else {
			tmp = (lastMatch) ? " " + $2 : $0; 
			i++;
			lastMatch = false;
		}
		return tmp;
	});
	if (lastMatch) result = result.replace(/\s*$/, "");
	while (0) { // loop forever
		var m = tmp.match(rex);
		if (m[0] == tmp) { // at end
			if (m[2] != token) {
				result += m[0];
				i++;
			}
			tmp = "";
			break;
		}
		if (m[2] == token) { // match
			var offset = m[0].length - (i ? 1 : 0);
			tmp = tmp.substring(offset);
		}
		else {
			i++;
			result += m[1] + m[2];
			var offset = m[1].length + m[2].length;
			tmp = tmp.substring(offset);
		}
	}
	if (result == text) return;
	this._setText(result);
}
DOMTokenList.prototype.toggle = function(token) {
	if (this.contains(token)) this.remove(token);
	else this.add(token);		
}
DOMTokenList.prototype._getTokens = function() {
	var text = this._getText();
	if (!text) return [];
	return text.split(/\s+/);
}

var NodeList = function() {}

return {
	Node: Node,
	Text: Text,
	Document: Document,
	Element: Element,
	DOMException: DOMException,
	DOMTokenList: DOMTokenList,
	NodeList: NodeList
};

})();

Meeko.XPL.Namespace.enhance(window, Meeko.DOM.Core);


]]>
</script>
</head>
</html>
