<?xml version="1.0"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<script>
<![CDATA[
// FIXME all the Array methods that accept a callback should clone the array before running

if (!this.Meeko) this.Meeko = {};

Meeko['ECMAScript5'] = (function() {

var global = this;

var Object = function() {}
Object.prototype = {};

var legacy_defineProperty = function(object, field, desc) { // this is a shim for legacy getters, setters
	if ((desc.get || desc.set) && desc.value != null) throw "value is incompatible with get, set";
	if (desc.value != null) {
		if (delete object[field] && object[field] == null) object[field] = desc.value; 
		else object.__defineGetter__(field, function() { return desc.value; });
	}
	if (desc.get) object.__defineGetter__(field, desc.get);
	if (desc.set) object.__defineSetter__(field, desc.set);
	return object;
}
var ie6_defineProperty = function(object, field, desc) { 
	if ((desc.get || desc.set) && undefined != desc.value) throw "value is incompatible with get, set";
	if (desc.set) throw "setters not implemented";
	var value = (desc.get) ? {
			valueOf: desc.get.bind(object),
			toString: desc.get.bind(object)
		} : desc.value;
	try { object[field] = value; }
	catch (error) {
		if (object.nodeType != 1) throw "Object.defineProperty not valid for non-Element nodes";
		var attr = document.createAttribute(field);
		attr.nodeValue = value;
		object.setAttributeNode(attr);
	}
	return object;
}
var ie8_defineProperty = function(object, field, desc) { // FIXME refactor common code with ie6_defineProperty
	try {
		if (desc.value != null && object[field] != null) { // NOTE use getters to override native properties in IE8
			var getter = function() { return arguments.callee.__value__; }
			getter.__value__ = desc.value;
			global.Object._defineProperty(object, field, { get: getter });
		}
		else global.Object._defineProperty(object, field, desc);
	}
	catch (error) {
		if ((desc.get || desc.set) && undefined != desc.value) throw "value is incompatible with get, set";
		if (desc.set) throw "setters not implemented";
		var value = (desc.get) ? {
				valueOf: desc.get.bind(object),
				toString: desc.get.bind(object)
			} : desc.value;
		object[field] = value;
	}
	return object;
}
if (global.Object.defineProperty) {
	try { global.Object.defineProperty({}, "_x", { get: function() {}}); }
	catch (error) {
		global.Object._defineProperty = global.Object.defineProperty;
		global.Object.defineProperty = null; // so our method gets added to global Object
		Object.defineProperty = ie8_defineProperty;
	}	
}
else Object.defineProperty = (global.Object.prototype.__defineGetter__) ? legacy_defineProperty :	ie6_defineProperty;

	
// NOTE non-standard Object methods
Object.copy = function(dest, source, fields, override) {
	function _copy(dst, src, name, over) {
		if (!over && (dst.hasOwnProperty && dst.hasOwnProperty(name) || dst[name] != null)) return;
		dst[name] = src[name];
	}
	if (fields && fields.length) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_copy(dest, source, name, override);
		}
	}
	else {
		for (var name in source) _copy(dest, source, name, override);
	}
	return dest;
}

Object.toLoggerString = function(object) { // NOTE the complexity here is work-arounds for Safari-2
	var string = "";
	for (var field in object) {
		var slot = object[field];
		var t = typeof slot;
		var sz;
		try { if (t == "object" && slot.length) t = "array"; }
		catch (error) { }
		try { var sz = "" + slot; }
		catch (error) { t = "null"; }
		if (t == "function") string += field + ": " + "function() {}" + "\n";
		else if (t == "array") string += field + ": " + "[ " + slot + " ]" + "\n";
		else if (t == "null") string += field + ": " + "null" + "\n";
		else string += field + ": " + slot + "\n";
	}
	return string;
}

Object.forEach = function(object, callback, context) {
	for (var key in object) {
		var val = object[key];
		if (typeof val != "function") callback.call(context, val, key, object);
	}
}

var Array = function() {
	return global.Array.apply(this, arguments);
}
Array.prototype = [];

Array.prototype.indexOf = function(testVal, start) {
	var array = this;
	var n = array.length;
	if (start == null) start = 0;
	for (var i=start; i<n; i++) {
		var val = array[i];
		if (val === testVal) return i;
	}
	return -1;
}
Array.prototype.lastIndexOf = function(testVal, start) {
	var array = this;
	var n = array.length;
	if (start == null) start = n-1;
	for (var i=start; i>=0; i--) {
		var val = array[i];
		if (val === testVal) return i;
	}
	return -1;
}
Array.prototype.every = function(callback, context) {
	var array = this;
	var n = array.length;
	for (var i=0; i<n; i++) {
		var val = array[i];
		if (val == null) continue;
		if (!callback.call(context, val, i, array)) return false;
	}
	return true;
}
Array.prototype.some = function(callback, context) {
	var array = this;
	var n = array.length;
	for (var i=0; i<n; i++) {
		var val = array[i];
		if (val == null) continue;
		if (callback.call(context, val, i, array)) return true;
	}
	return false;
}
Array.prototype.forEach = function(callback, context) {
	var array = this;
	var n = array.length;
	for (var i=0; i<n; i++) {
		var val = array[i];
		if (val == null) continue;
		callback.call(context, val, i, array);
	}
}
Array.prototype.filter = function(callback, context) {
	var array = this;
	var out = [];
	var n = array.length;
	for (var i=0; i<n; i++) {
		var val = array[i];
		if (val == null) continue;
		callback.call(context, val, i, array) && out.push(val);
	}
	return out;
}
Array.prototype.map = function(callback, context) {
	var array = this;
	var out = [];
	var n = array.length;
	for (var i=0; i<n; i++) {
		var val = array[i];
		if (val == null) continue;
		out[i] = callback.call(context, array[i], i, array);
	}
	return out;
}

// NOTE non-standard Array methods
Array.prototype.compare = function(array2, cmp) { // NOTE compares n elements where n is length of shorter array
	var array1 = this;
	if (!cmp) cmp = function(a,b) { return (a < b) ? -1 : (a > b) ? 1 : 0 };
	var rc = 0;
	var n1 = array1.length, n2 = array2.length, n = (n1 <= n2) ? n1 : n2;
	for (var i=0; i<n; i++) {
		if (rc = cmp(array1[i], array2[i])) return rc;
	}
	return rc;
}

Array.slice = function(array, start, end) {
	var slice = this.prototype.slice;
	return (end === undefined) ?
		slice.call(array, start) :
		slice.call(array, start, end);
}
Array.indexOf = function(array, val, start) { return this.prototype.indexOf.call(array, val, start); }
Array.lastIndexOf = function(array, val, start) { return this.prototype.lastIndexOf.call(array, val, start); }
Array.every = function(array, callback, context) { return this.prototype.every.call(array, callback, context); }
Array.filter = function(array, callback, context) { return this.prototype.filter.call(array, callback, context); }
Array.forEach = function(array, callback, context) { return this.prototype.forEach.call(array, callback, context); }
Array.map = function(array, callback, context) { return this.prototype.map.call(array, callback, context); }
Array.some = function(array, callback, context) { return this.prototype.some.call(array, callback, context); }
Array.compare = function(array1, array2, cmp) { return this.prototype.compare.call(array1, array2, cmp); }

var Function = function() {
		return global.Function.apply(this, arguments);
}
Function.prototype = function() {};

Function.prototype.bind = function(self) {
	var callee = this;
	var params = [].slice.call(arguments, 1);
	return (params.length) ?
		function() { return callee.apply(self, arguments); } :
		function() { return callee.apply(self, params.concat([].slice.call(arguments, 0))); } 
}

return {
	Object: Object,
	Array: Array,
	Function: Function
}

})();

Meeko.XPL.Namespace.enhance(window, Meeko['ECMAScript5']);

]]>
</script>
</head>
</html>